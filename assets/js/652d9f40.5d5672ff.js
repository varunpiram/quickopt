"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[531],{106:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var t=i(4848),s=i(8453);const r={sidebar_position:1},o="Usage",l={id:"genetic/usage",title:"Usage",description:"genetic_double",source:"@site/docs/genetic/usage.md",sourceDirName:"genetic",slug:"/genetic/usage",permalink:"/quickopt/docs/genetic/usage",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Genetic Algorithm",permalink:"/quickopt/docs/category/genetic-algorithm"},next:{title:"Description",permalink:"/quickopt/docs/genetic/description"}},d={},c=[{value:"<code>genetic_double</code>",id:"genetic_double",level:2},{value:"Signature",id:"signature",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Output",id:"output",level:3},{value:"Notes",id:"notes",level:3},{value:"<code>genetic_int</code>",id:"genetic_int",level:2},{value:"Signature",id:"signature-1",level:3},{value:"Parameters",id:"parameters-1",level:3},{value:"Output",id:"output-1",level:3},{value:"Notes",id:"notes-1",level:3},{value:"<code>genetic_string</code>",id:"genetic_string",level:2},{value:"Signature",id:"signature-2",level:3},{value:"Parameters",id:"parameters-2",level:3},{value:"Output",id:"output-2",level:3},{value:"Notes",id:"notes-2",level:3}];function a(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"usage",children:"Usage"}),"\n",(0,t.jsx)(n.h2,{id:"genetic_double",children:(0,t.jsx)(n.code,{children:"genetic_double"})}),"\n",(0,t.jsxs)(n.p,{children:["Uses a genetic algorithm to ",(0,t.jsx)(n.strong,{children:"maximize"})," a function of double inputs."]}),"\n",(0,t.jsx)(n.h3,{id:"signature",children:"Signature"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"genetic_double(fitness, mutate, generate, seed=[], population_size=100, reproduction_ct=10, survivor_ct=0, mutation_rate=0.1, generations=100, verbose=1)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"fitness"})," - ",(0,t.jsx)(n.strong,{children:"function: (input: List[float]) -> float"})," : The fitness function. It should take a list of doubles as input and return a double representing the fitness value."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"mutate"})," - ",(0,t.jsx)(n.strong,{children:"function: (input: List[float]) -> List[float]"})," : The mutation function. It should take a list of doubles as input and return a new list of doubles representing the mutated parameters."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"generate"})," - ",(0,t.jsx)(n.strong,{children:"function: () -> List[float]"})," : The generate function. It generates a set of parameters to be used in the initial population, ideally randomly."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"seed"})," - ",(0,t.jsx)(n.strong,{children:"List[List[float]]"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : Seed population. A predefined set of parameters to be used in the initial population. Default is an empty list."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"population_size"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The size of the population. More is better but slower. Default is 100."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"reproduction_ct"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The number of individuals that will reproduce each generation. More leads to more diversity but slower convergence. Default is 10."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"survivor_ct"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The number of individuals that will survive each generation. These individuals are not affected by mutation. More leads to more stability but could harm diversity. Default is 0."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"mutation_rate"})," - ",(0,t.jsx)(n.strong,{children:"double"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The probability that a mutation will occur on a given individual. Default is 0.1."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"generations"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The number of generations to run the algorithm. Default is 100."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"verbose"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The verbosity level. ",(0,t.jsx)(n.code,{children:"0"})," for no output, ",(0,t.jsx)(n.code,{children:"1"})," for average and top fitness each generation. Default is 1."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"output",children:"Output"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"best_params"})," - ",(0,t.jsx)(n.strong,{children:"List[float]"}),": The best set of parameters found by the genetic algorithm."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"notes",children:"Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Minimization can be achieved by returning the negative of objective function values."}),"\n",(0,t.jsxs)(n.li,{children:["Ensure ",(0,t.jsx)(n.code,{children:"reproduction_ct"})," is not greater than ",(0,t.jsx)(n.code,{children:"population_size"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Search space boundaries should be implicitly defined within ",(0,t.jsx)(n.code,{children:"generate"})," and ",(0,t.jsx)(n.code,{children:"mutate"})," functions."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"generate"})," function should handle boundary conditions if necessary."]}),"\n",(0,t.jsxs)(n.li,{children:["Adjust the verbosity level with the ",(0,t.jsx)(n.code,{children:"verbose"})," parameter to control the amount of output during the generations."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"genetic_int",children:(0,t.jsx)(n.code,{children:"genetic_int"})}),"\n",(0,t.jsxs)(n.p,{children:["Uses a genetic algorithm to ",(0,t.jsx)(n.strong,{children:"maximize"})," a function of integer inputs."]}),"\n",(0,t.jsx)(n.h3,{id:"signature-1",children:"Signature"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"genetic_int(fitness, mutate, generate, seed=[], population_size=100, reproduction_ct=10, survivor_ct=0, mutation_rate=0.1, generations=100, verbose=1)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"parameters-1",children:"Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"fitness"})," - ",(0,t.jsx)(n.strong,{children:"function: (input: List[int]) -> float"})," : The fitness function. It should take a list of integers as input and return a double representing the fitness value."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"mutate"})," - ",(0,t.jsx)(n.strong,{children:"function: (input: List[int]) -> List[int]"})," : The mutation function. It should take a list of integers as input and return a new list of integers representing the mutated parameters."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"generate"})," - ",(0,t.jsx)(n.strong,{children:"function: () -> List[int]"})," : The generate function. It generates a set of parameters to be used in the initial population, ideally randomly."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"seed"})," - ",(0,t.jsx)(n.strong,{children:"List[List[int]]"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : Seed population. A predefined set of parameters to be used in the initial population. Default is an empty list."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"population_size"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The size of the population. More is better but slower. Default is 100."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"reproduction_ct"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The number of individuals that will reproduce each generation. More leads to more diversity but slower convergence. Default is 10."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"survivor_ct"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The number of individuals that will survive each generation. These individuals are not affected by mutation. More leads to more stability but could harm diversity. Default is 0."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"mutation_rate"})," - ",(0,t.jsx)(n.strong,{children:"double"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The probability that a mutation will occur on a given individual. Default is 0.1."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"generations"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The number of generations to run the algorithm. Default is 100."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"verbose"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The verbosity level. ",(0,t.jsx)(n.code,{children:"0"})," for no output, ",(0,t.jsx)(n.code,{children:"1"})," for average and top fitness each generation. Default is 1."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"output-1",children:"Output"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"best_params"})," - ",(0,t.jsx)(n.strong,{children:"List[int]"}),": The best set of parameters found by the genetic algorithm."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"notes-1",children:"Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Minimization can be achieved by returning the negative of objective function values."}),"\n",(0,t.jsxs)(n.li,{children:["Ensure ",(0,t.jsx)(n.code,{children:"reproduction_ct"})," is not greater than ",(0,t.jsx)(n.code,{children:"population_size"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Search space boundaries should be implicitly defined within ",(0,t.jsx)(n.code,{children:"generate"})," and ",(0,t.jsx)(n.code,{children:"mutate"})," functions."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"generate"})," function should handle boundary conditions if necessary."]}),"\n",(0,t.jsxs)(n.li,{children:["Adjust the verbosity level with the ",(0,t.jsx)(n.code,{children:"verbose"})," parameter to control the amount of output during the generations."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"genetic_string",children:(0,t.jsx)(n.code,{children:"genetic_string"})}),"\n",(0,t.jsxs)(n.p,{children:["Uses a genetic algorithm to ",(0,t.jsx)(n.strong,{children:"maximize"})," a function of string inputs."]}),"\n",(0,t.jsx)(n.h3,{id:"signature-2",children:"Signature"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"genetic_string(fitness, mutate, generate, seed=[], population_size=100, reproduction_ct=10, survivor_ct=0, mutation_rate=0.1, generations=100, verbose=1)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"parameters-2",children:"Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"fitness"})," - ",(0,t.jsx)(n.strong,{children:"function: (input: List[str]) -> float"})," : The fitness function. It should take a list of strings as input and return a double representing the fitness value."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"mutate"})," - ",(0,t.jsx)(n.strong,{children:"function: (input: List[str]) -> List[str]"})," : The mutation function. It should take a list of strings as input and return a new list of strings representing the mutated parameters."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"generate"})," - ",(0,t.jsx)(n.strong,{children:"function: () -> List[str]"})," : The generate function. It generates a set of parameters to be used in the initial population, ideally randomly."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"seed"})," - ",(0,t.jsx)(n.strong,{children:"List[List[str]]"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : Seed population. A predefined set of parameters to be used in the initial population. Default is an empty list."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"population_size"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The size of the population. More is better but slower. Default is 100."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"reproduction_ct"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The number of individuals that will reproduce each generation. More leads to more diversity but slower convergence. Default is 10."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"survivor_ct"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The number of individuals that will survive each generation. These individuals are not affected by mutation. More leads to more stability but could harm diversity. Default is 0."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"mutation_rate"})," - ",(0,t.jsx)(n.strong,{children:"double"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The probability that a mutation will occur on a given individual. Default is 0.1."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"generations"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The number of generations to run the algorithm. Default is 100."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"verbose"})," - ",(0,t.jsx)(n.strong,{children:"int"}),", ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"optional"})})," : The verbosity level. ",(0,t.jsx)(n.code,{children:"0"})," for no output, ",(0,t.jsx)(n.code,{children:"1"})," for average and top fitness each generation. Default is 1."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"output-2",children:"Output"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"best_params"})," - ",(0,t.jsx)(n.strong,{children:"List[str]"}),": The best set of parameters found by the genetic algorithm."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"notes-2",children:"Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Minimization can be achieved by returning the negative of objective function values."}),"\n",(0,t.jsxs)(n.li,{children:["Ensure ",(0,t.jsx)(n.code,{children:"reproduction_ct"})," is not greater than ",(0,t.jsx)(n.code,{children:"population_size"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Search space boundaries should be implicitly defined within ",(0,t.jsx)(n.code,{children:"generate"})," and ",(0,t.jsx)(n.code,{children:"mutate"})," functions."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"generate"})," function should handle boundary conditions if necessary."]}),"\n",(0,t.jsxs)(n.li,{children:["Adjust the verbosity level with the ",(0,t.jsx)(n.code,{children:"verbose"})," parameter to control the amount of output during the generations."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var t=i(6540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);