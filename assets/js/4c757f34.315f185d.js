"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[186],{8636:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var i=t(4848),r=t(8453);const s={sidebar_position:1},a="Usage",l={id:"annealing/usage",title:"Usage",description:"anneal_double",source:"@site/docs/annealing/usage.md",sourceDirName:"annealing",slug:"/annealing/usage",permalink:"/quickopt/docs/annealing/usage",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Simulated Annealing",permalink:"/quickopt/docs/category/simulated-annealing"},next:{title:"Description",permalink:"/quickopt/docs/annealing/description"}},o={},c=[{value:"<code>anneal_double</code>",id:"anneal_double",level:2},{value:"Signature",id:"signature",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Output",id:"output",level:3},{value:"Notes",id:"notes",level:3},{value:"<code>anneal_int</code>",id:"anneal_int",level:2},{value:"Signature",id:"signature-1",level:3},{value:"Parameters",id:"parameters-1",level:3},{value:"Output",id:"output-1",level:3},{value:"Notes",id:"notes-1",level:3},{value:"<code>anneal_string</code>",id:"anneal_string",level:2},{value:"Signature",id:"signature-2",level:3},{value:"Parameters",id:"parameters-2",level:3},{value:"Output",id:"output-2",level:3},{value:"Notes",id:"notes-2",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.h2,{id:"anneal_double",children:(0,i.jsx)(n.code,{children:"anneal_double"})}),"\n",(0,i.jsxs)(n.p,{children:["Uses simulated annealing to ",(0,i.jsx)(n.strong,{children:"minimize"})," a function of double inputs."]}),"\n",(0,i.jsx)(n.h3,{id:"signature",children:"Signature"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"anneal_double(funct, initial, neighbor, iterations=100, temperature=lambda iter: pow(0.999, iter), acceptance=lambda new_value, current_value, temperature: exp(-(new_value - current_value) / temperature), verbose=1)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"funct"})," - ",(0,i.jsx)(n.strong,{children:"function: (input: List[float]) -> float"})," : The function to be minimized. It should take a list of doubles as input and return a double."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"initial"})," - ",(0,i.jsx)(n.strong,{children:"List[float]"})," : The initial guess for the parameters. This is the starting point for the simulated annealing process."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"neighbor"})," - ",(0,i.jsx)(n.strong,{children:"function: (input: List[float]) -> List[float]"})," : The neighbor function that generates a new set of parameters based on the current set. It should take a vector of doubles as input and return a new vector of doubles."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"iterations"})," - ",(0,i.jsx)(n.strong,{children:"int"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"optional"})})," : The number of iterations to run the algorithm. Default is 100."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"temperature"})," - ",(0,i.jsx)(n.strong,{children:"function: (input: int) -> float"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"optional"})})," : The temperature schedule that determines the temperature at each iteration. It should take an iteration number as input and return a temperature double. Default returns ",(0,i.jsx)(n.code,{children:"0.999**iteration"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"acceptance"})," - ",(0,i.jsx)(n.strong,{children:"function: (input: float, float, float) -> float"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"optional"})})," : Used to define a custom acceptance probability function, which determines whether to accept a new set of parameters based on the current set and temperature. It should take a new value, the current value, and the temperature - three doubles (",(0,i.jsx)(n.code,{children:"new_value"}),", ",(0,i.jsx)(n.code,{children:"current_value"}),", ",(0,i.jsx)(n.code,{children:"temperature"}),") - as inputs, and return a double in [0,1]. Default uses the Metropolis-Hastings algorithm in case T=1 and proposal distribution is symmetric."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"verbose"})," - ",(0,i.jsx)(n.strong,{children:"int"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"optional"})})," : The verbosity level. ",(0,i.jsx)(n.code,{children:"0"})," for final output, ",(0,i.jsx)(n.code,{children:"1"})," for output at each iteration. Default is 1."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"output",children:"Output"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"best_params"})," - ",(0,i.jsx)(n.strong,{children:"List[float]"}),": The best set of parameters found by the simulated annealing process."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"notes",children:"Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Maximization can be achieved by returning the negative of objective function values."}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"temperature"})," function should typically return a value in the range (0, 1] and must be decreasing over iterations."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"acceptance"})," function must return a value between 0 and 1."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"neighbor"})," function should handle boundary conditions if necessary."]}),"\n",(0,i.jsxs)(n.li,{children:["Adjust the verbosity level with the ",(0,i.jsx)(n.code,{children:"verbose"})," parameter to control the amount of output during the iterations."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"anneal_int",children:(0,i.jsx)(n.code,{children:"anneal_int"})}),"\n",(0,i.jsxs)(n.p,{children:["Uses simulated annealing to ",(0,i.jsx)(n.strong,{children:"minimize"})," a function of integer inputs."]}),"\n",(0,i.jsx)(n.h3,{id:"signature-1",children:"Signature"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"anneal_int(funct, initial, neighbor, iterations=100, temperature=lambda iter: pow(0.999, iter), acceptance=lambda new_value, current_value, temperature: exp(-(new_value - current_value) / temperature), verbose=1)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parameters-1",children:"Parameters"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"funct"})," - ",(0,i.jsx)(n.strong,{children:"function: (input: List[int]) -> float"})," : The function to be minimized. It should take a list of doubles as input and return a double."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"initial"})," - ",(0,i.jsx)(n.strong,{children:"List[int]"})," : The initial guess for the parameters. This is the starting point for the simulated annealing process."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"neighbor"})," - ",(0,i.jsx)(n.strong,{children:"function: (input: List[int]) -> List[float]"})," : The neighbor function that generates a new set of parameters based on the current set. It should take a vector of doubles as input and return a new vector of doubles."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"iterations"})," - ",(0,i.jsx)(n.strong,{children:"int"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"optional"})})," : The number of iterations to run the algorithm. Default is 100."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"temperature"})," - ",(0,i.jsx)(n.strong,{children:"function: (input: int) -> float"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"optional"})})," : The temperature schedule that determines the temperature at each iteration. It should take an iteration number as input and return a temperature double. Default returns ",(0,i.jsx)(n.code,{children:"0.999**iteration"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"acceptance"})," - ",(0,i.jsx)(n.strong,{children:"function: (input: int, int, float) -> float"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"optional"})})," : Used to define a custom acceptance probability function, which determines whether to accept a new set of parameters based on the current set and temperature. It should take a new value, the current value, and the temperature - three doubles (",(0,i.jsx)(n.code,{children:"new_value"}),", ",(0,i.jsx)(n.code,{children:"current_value"}),", ",(0,i.jsx)(n.code,{children:"temperature"}),") - as inputs, and return a double in [0,1]. Default uses the Metropolis-Hastings algorithm in case T=1 and proposal distribution is symmetric."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"verbose"})," - ",(0,i.jsx)(n.strong,{children:"int"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"optional"})})," : The verbosity level. ",(0,i.jsx)(n.code,{children:"0"})," for final output, ",(0,i.jsx)(n.code,{children:"1"})," for output at each iteration. Default is 1."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"output-1",children:"Output"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"best_params"})," - ",(0,i.jsx)(n.strong,{children:"List[int]"}),": The best set of parameters found by the simulated annealing process."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"notes-1",children:"Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Maximization can be achieved by returning the negative of objective function values."}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"temperature"})," function should typically return a value in the range (0, 1] and must be decreasing over iterations."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"acceptance"})," function must return a value between 0 and 1."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"neighbor"})," function should handle boundary conditions if necessary."]}),"\n",(0,i.jsxs)(n.li,{children:["Adjust the verbosity level with the ",(0,i.jsx)(n.code,{children:"verbose"})," parameter to control the amount of output during the iterations."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"anneal_string",children:(0,i.jsx)(n.code,{children:"anneal_string"})}),"\n",(0,i.jsxs)(n.p,{children:["Uses simulated annealing to ",(0,i.jsx)(n.strong,{children:"minimize"})," a function of string inputs."]}),"\n",(0,i.jsx)(n.h3,{id:"signature-2",children:"Signature"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"anneal_string(funct, initial, neighbor, iterations=100, temperature=lambda iter: pow(0.999, iter), acceptance=lambda new_value, current_value, temperature: exp(-(new_value - current_value) / temperature), verbose=1)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parameters-2",children:"Parameters"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"funct"})," - ",(0,i.jsx)(n.strong,{children:"function: (input: List[str]) -> float"})," : The function to be minimized. It should take a list of doubles as input and return a double."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"initial"})," - ",(0,i.jsx)(n.strong,{children:"List[str]"})," : The initial guess for the parameters. This is the starting point for the simulated annealing process."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"neighbor"})," - ",(0,i.jsx)(n.strong,{children:"function: (input: List[str]) -> List[float]"})," : The neighbor function that generates a new set of parameters based on the current set. It should take a vector of doubles as input and return a new vector of doubles."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"iterations"})," - ",(0,i.jsx)(n.strong,{children:"int"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"optional"})})," : The number of iterations to run the algorithm. Default is 100."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"temperature"})," - ",(0,i.jsx)(n.strong,{children:"function: (input: int) -> float"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"optional"})})," : The temperature schedule that determines the temperature at each iteration. It should take an iteration number as input and return a temperature double. Default returns ",(0,i.jsx)(n.code,{children:"0.999**iteration"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"acceptance"})," - ",(0,i.jsx)(n.strong,{children:"function: (input: str, str, float) -> float"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"optional"})})," : Used to define a custom acceptance probability function, which determines whether to accept a new set of parameters based on the current set and temperature. It should take a new value, the current value, and the temperature - three doubles (",(0,i.jsx)(n.code,{children:"new_value"}),", ",(0,i.jsx)(n.code,{children:"current_value"}),", ",(0,i.jsx)(n.code,{children:"temperature"}),") - as inputs, and return a double in [0,1]. Default uses the Metropolis-Hastings algorithm in case T=1 and proposal distribution is symmetric."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"verbose"})," - ",(0,i.jsx)(n.strong,{children:"int"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"optional"})})," : The verbosity level. ",(0,i.jsx)(n.code,{children:"0"})," for final output, ",(0,i.jsx)(n.code,{children:"1"})," for output at each iteration. Default is 1."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"output-2",children:"Output"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"best_params"})," - ",(0,i.jsx)(n.strong,{children:"List[str]"}),": The best set of parameters found by the simulated annealing process."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"notes-2",children:"Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Maximization can be achieved by returning the negative of objective function values."}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"temperature"})," function should typically return a value in the range (0, 1] and must be decreasing over iterations."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"acceptance"})," function must return a value between 0 and 1."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"neighbor"})," function should handle boundary conditions if necessary."]}),"\n",(0,i.jsxs)(n.li,{children:["Adjust the verbosity level with the ",(0,i.jsx)(n.code,{children:"verbose"})," parameter to control the amount of output during the iterations."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);